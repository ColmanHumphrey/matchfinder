% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mahal.R
\name{weighted_mahal}
\alias{weighted_mahal}
\title{computes weighted Mahalanobis distance, using Choleski decomp.}
\usage{
weighted_mahal(
  x_mat,
  cov_x,
  weight_vec = NULL,
  treat_vec = NULL,
  sqrt_mahal = TRUE,
  partial_index = NULL
)
}
\arguments{
\item{x_mat}{numeric matrix (adjust non-numeric columns prior),
already rank-adjusted if desired}

\item{cov_x}{covariance of x, calculated potentially with ranks}

\item{weight_vec}{vector of weights corresponding to columns of x_mat,
giving weights relative to "raw" (ranked) Mahalanobis.
Note that the resulting matrix does depend on the scale of the
weight vector, but the matching won't: scaling the Mahalanobis
matrix has no effect on distance minimising pairs etc}

\item{treat_vec}{optionally specify which units are treated.
If NULL (default), will just return nrow(x_mat) x nrow(x_mat) distance
matrix of all pairs. Can be logicals or {0, 1}}

\item{sqrt_mahal}{logical, default TRUE; do you want regular Mahalanobis:
d(x_i, x_j) = (x_i - x_j)' ISIG (x_i - x_j)
or the square root? (in weighted, ISIG = W SIGMA^-1 W)}

\item{partial_index}{In some cases, you want a subset of the full
N x N matrix, but you can't partition it like you want
with treat_vec. e.g. you want
full_dist[c(1, 2, 3), 1:10]
then use
partial_index = list(c(1,2,3), 1:10)}
}
\value{
returns a matrix of pairwise distances; the relevant indexing
  depends on `treat_vec` and `partial_index`
}
\description{
Note: def. of weighted:
\eqn{d(x_i, x_j) = (x_i - x_j)' W (\Sigma)^(-1) W (x_i - x_j)}
where \eqn{W = \text{diag}(weight_vec)}
R chol gives U s.t. U' U = S (i.e. U = chol(S))
so in general we want:
  (x_i - x_j)' W (U' U)^(-1) W (x_i - x_j)
= (x_i - x_j)' W U^(-1) (U')^(-1) W (x_i - x_j)
= x_i' W U^(-1) (U')^(-1) W x_i +
  x_j' W U^(-1) (U')^(-1) W x_j
  - 2 x_i' W U^(-1) (U')^(-1) W x_j
}
\details{
Solving the above is easy if we have y_i = (U')^(-1) W x_i
or W^(-1) U' y_i = x_i,
which is simple by forwardsolve. Then we have:
dist(x_i, x_j) = ||y_i||^2 + ||y_j||^2 - 2 y_i' y_j
Letting Ymat = (y_1', y_2', .... ,y_n')'
[which can get in one line, Ymat' = forwardsolve(W^(-1) U', x_mat')]
the first two parts are just rowSums(Ymat^2) [note that code uses Ymat', thus colSums]
[add outer(.,.) to finish]
and the last is Ymat Ymat'
}
